
R version 2.15.0 (2012-03-30)
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # This is file ../spam0.29-0/tests/subsetting.R
> # This file is part of the spam package, 
> #      http://www.math.uzh.ch/furrer/software/spam/
> # written and maintained by Reinhard Furrer.
>      
> 
> 
> 
> 
> 
> 
> 
> 
> #options( echo=FALSE)
> library( spam, warn.conflict=FALSE)
Spam version 0.29-0 (2012-04-11) is loaded.
Type 'help( Spam)' or 'demo( spam)' for a short introduction 
and overview of this package.
Help for individual functions is also obtained by adding the
suffix '.spam' to the function name, e.g. 'help( chol.spam)'.
> 
> 
> test.for.zero <- function( xtest, xtrue, tol= 1.0e-6, relative=FALSE,
+ tag=NULL){
+   # slightly different test function!
+   if( !is.null(tag)){
+      cat( "testing: ", tag, fill=TRUE)}
+ 
+   denom<-   ifelse( relative, mean( abs(c(xtrue))),1.0)
+ 
+   if (any(dim(xtest)!=dim(xtrue)))
+     return( cat("## FAILED dimensions  ", dim(xtest), " and ", dim(xtrue),
+               fill=TRUE))
+   test.value <- sum( abs(c(xtest) - c( xtrue) ),na.rm=T ) /denom
+   if(   test.value < tol ){
+           cat("** PASSED test at tolerance ", tol, fill=TRUE)}
+   else{ cat( "## FAILED test value = ", test.value, " at tolerance ", tol,
+               fill=TRUE)}
+ 
+ }
> 
> 
> 
> # subsetting:
> ########################################################################
> 
> 
> # construct matrices (should be at least 3x5, with n<m):
> n <- 10
> m <- 15
> 
> set.seed(14)
> tt <- matrix(rnorm(m*n),n,m)
> tt[tt<0] <- 0
> 
> ss <- as.spam(tt)
> 
> cat("Testing subsetting\n")
Testing subsetting
> test.for.zero(ss[],tt[])      # ok
** PASSED test at tolerance  1e-06
> test.for.zero(ss[,],tt[,])    # ok
** PASSED test at tolerance  1e-06
> test.for.zero(ss[1,],tt[1,])  # ok
** PASSED test at tolerance  1e-06
> test.for.zero(ss[,2],tt[,2])  # ok
** PASSED test at tolerance  1e-06
> test.for.zero(ss[1,3],tt[1,3])# ok
** PASSED test at tolerance  1e-06
> test.for.zero(ss[3:1,],tt[3:1,])# ok
** PASSED test at tolerance  1e-06
> 
> 
> rw <- sample(c(T,F),nrow(tt),rep=T)
> cl <- sample(c(T,F),ncol(tt),rep=T)
> test.for.zero(ss[rw,cl],tt[rw,cl])
** PASSED test at tolerance  1e-06
> test.for.zero(ss[rw],tt[rw])
** PASSED test at tolerance  1e-06
> 
> 
> 
> 
> rw <- c(1,3);cl <- 1:3;
> test.for.zero(ss[rw,cl],tt[rw,cl])
** PASSED test at tolerance  1e-06
> test.for.zero(ss[-rw,cl],tt[-rw,cl])
** PASSED test at tolerance  1e-06
> test.for.zero(ss[-rw,-cl],tt[-rw,-cl])
** PASSED test at tolerance  1e-06
> rw <- c(3,1);cl <- 1:3; test.for.zero(ss[rw,cl],tt[rw,cl])
** PASSED test at tolerance  1e-06
> rw <- c(3,1,2,1);cl <- 1:3; test.for.zero(ss[rw,cl],tt[rw,cl])
** PASSED test at tolerance  1e-06
> 
> tmp <- cbind(sample(1:3,24,rep=T),sample(1:5,24,rep=T))
> test.for.zero(ss[tmp],tt[tmp])
** PASSED test at tolerance  1e-06
> 
> 
> test.for.zero(diag(10)[1:2,9:10],diag.spam(10)[1:2,9:10],rel=F)
** PASSED test at tolerance  1e-06
> 
> rs <- sample(c(0,1:(2*n)),2*m,replace=T)
> test.for.zero(ss[rs],tt[rs])
** PASSED test at tolerance  1e-06
> # NAs simply work!
> rs <- sample(c(0,1:(2*n),NA),2*m,replace=T)
> test.for.zero(ss[rs],tt[rs])
** PASSED test at tolerance  1e-06
> 
> rs <- sample(c(T,F,NA),2*m,replace=T)
> test.for.zero(ss[rs],tt[rs])
** PASSED test at tolerance  1e-06
> 
> if (F) {
+ # large timing example
+ 
+   n <- 100
+   m <- 15000
+ 
+   set.seed(14)
+   tt <- matrix(rnorm(m*n,mean=-1),n,m)
+   tt[tt<0] <- 0
+ 
+   ss <- as.spam(tt)
+ 
+   set.seed(14)
+   system.time(for (i in 1:100) {
+     spam:::subset.rows.spam(ss,sample(1:n,10)) })
+   set.seed(14)
+   system.time(for (i in 1:100) {
+     spam:::subset.spam(ss,sample(1:n,10),1:m) })
+ 
+ }
> options( echo=TRUE)
> 
> proc.time()
   user  system elapsed 
  0.864   0.020   0.933 
